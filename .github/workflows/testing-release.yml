name: Testing Release Build

on:
  push:
    #    branches: [ testing ]
    tags: [ 'testing-*' ]
    #  pull_request:
    #    branches: [ testing ]

jobs:
  build:
    strategy:
      fail-fast: false # Prevent other jobs from stopping if one fails
      matrix:
        include:
          - os_name: windows-latest
            os_for_build: windows-latest # Electron builder OS target
            npm_build_script: build:win
            arch_suffix: "" # No suffix for Windows in this setup
          - os_name: macos-13 # For x64 builds (macos-13 is Intel)
            os_for_build: macos-latest # Electron builder OS target
            npm_build_script: build:mac:x64
            arch_suffix: x64
          - os_name: macos-14 # For arm64 builds (macos-14 is Apple Silicon)
            os_for_build: macos-latest # Electron builder OS target
            npm_build_script: build:mac:arm64
            arch_suffix: arm64
    runs-on: ${{ matrix.os_name }}
    # Add permissions block here for the job
    permissions:
      contents: write
      packages: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}


    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        ref: ${{ github.ref }} # Checkout the specific tag that triggered the workflow
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python 3.12
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'  # Updated to Python 3.12

    - name: Create virtual environment
      shell: bash
      run: |
        python -m venv venv
        if [ "${{ runner.os }}" == "Windows" ]; then
          source venv/Scripts/activate
        else
          source venv/bin/activate
        fi
        echo "VIRTUAL_ENV=$VIRTUAL_ENV" >> $GITHUB_ENV

    - name: Verify Python version
      shell: bash
      run: |
        if [ "${{ runner.os }}" == "Windows" ]; then
          source venv/Scripts/activate
          venv/Scripts/python.exe --version
        else
          source venv/bin/activate
          python --version  # Verify correct Python version
        fi

    - name: Install dependencies
      shell: bash
      run: |
        if [ "${{ runner.os }}" == "Windows" ]; then
          source venv/scripts/activate
          venv/Scripts/python.exe -m pip install --upgrade pip
          venv/Scripts/python.exe -m pip install -r requirements.txt
        else
          source venv/bin/activate
          pip install --upgrade pip
          pip install -r requirements.txt
        fi

    - name: Install project in editable mode
      shell: bash
      run: |
        if [ "${{ runner.os }}" == "Windows" ]; then
          source venv/scripts/activate
          venv/Scripts/python.exe -m pip install -e .
        else
          source venv/bin/activate
          pip install -e .
        fi

    - name: Show location and files
      shell: bash
      run: |
        pwd
        ls

    - name: Run build script
      shell: bash
      run: |
        if [ "${{ runner.os }}" == "Windows" ]; then
          source venv/scripts/activate
        else
          source venv/bin/activate
        fi
        chmod +x bin/build
        bin/build --skip-npm-build --skip-git-tag

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'  # Matches Electron and other dependencies version requirements

    - name: Install npm dependencies
      shell: bash
      run: |
        npm install

    - name: Build frontend for ${{ matrix.os_name }}
      shell: bash
      run: |
        npm run ${{ matrix.npm_build_script }}
        echo "--- Contents of dist after build (OS: ${{ runner.os }}, Arch: ${{ matrix.arch_suffix }}) ---"
        ls -R dist # IMPORTANT: To see what electron-builder created and where

    - name: Determine Archive Name
      id: archive_name
      shell: bash
      env: # Pass matrix variables to the script environment
        OS_NAME_MATRIX: ${{ matrix.os_name }}
        ARCH_SUFFIX_MATRIX: ${{ matrix.arch_suffix }}
      run: |
        # Extract tag name (e.g., testing-v1.0.0)
        TAG_NAME="${{ github.ref_name }}"
        # Extract branch part (e.g., testing)
        BRANCH_PART="${TAG_NAME%-v*}"
        # Extract version part (e.g., v1.0.0)
        VERSION_PART="${TAG_NAME#*-}"
        # Clean the OS name (e.g., macos-13 -> macos, windows-latest -> windows)
        OS_NAME_CLEANED="$(echo "$OS_NAME_MATRIX" | sed 's/-latest$//' | sed 's/-[0-9]*$//')"
        ARCH_SUFFIX="$ARCH_SUFFIX_MATRIX"
        FILENAME_ARCH_SUFFIX=""
        if [ -n "$ARCH_SUFFIX" ]; then
          FILENAME_ARCH_SUFFIX="-${ARCH_SUFFIX}"
        fi

        # Construct the desired filename, use .exe for Windows
        if [ "${{ runner.os }}" == "Windows" ]; then
          echo "ARCHIVE_FILENAME=ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}.exe" >> $GITHUB_ENV
          echo "Generated filename: ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}.exe"
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          echo "ARCHIVE_FILENAME=ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}${FILENAME_ARCH_SUFFIX}.dmg" >> $GITHUB_ENV
          echo "Generated filename: ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}${FILENAME_ARCH_SUFFIX}.dmg"
        else
          # Assuming Linux still uses zip for now
          echo "ARCHIVE_FILENAME=ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}${FILENAME_ARCH_SUFFIX}.zip" >> $GITHUB_ENV
          echo "Generated filename: ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}${FILENAME_ARCH_SUFFIX}.zip"
        fi

        # Output version part for use in other steps
        echo "version-part=${VERSION_PART}" >> $GITHUB_OUTPUT
        # Correctly output the GITHUB_ENV variable's value
        # The GITHUB_ENV file is processed after the script, so we need to echo the variable name for the next step to use it via env context
        # Or, more directly, output the value itself if we construct it here.
        # For simplicity, let's ensure ARCHIVE_FILENAME is available in GITHUB_OUTPUT for the next step.
        # The GITHUB_ENV method is fine, the next step just needs to access it via ${{ env.ARCHIVE_FILENAME }}
        # To be explicit for GITHUB_OUTPUT:
        if [ "${{ runner.os }}" == "Windows" ]; then
          echo "archive_filename_out=ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}.exe" >> $GITHUB_OUTPUT
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          echo "archive_filename_out=ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}${FILENAME_ARCH_SUFFIX}.dmg" >> $GITHUB_OUTPUT
        else
          echo "archive_filename_out=ainara-polaris-${BRANCH_PART}-${VERSION_PART}-${OS_NAME_CLEANED}${FILENAME_ARCH_SUFFIX}.zip" >> $GITHUB_OUTPUT
        fi

    - name: Locate and Prepare Artifacts
      id: prep_artifacts
      shell: bash
      env:
        ARCHIVE_FILENAME: ${{ steps.archive_name.outputs.archive_filename_out }}
        ARCH_SUFFIX: ${{ matrix.arch_suffix }}
        APP_VERSION: ${{ steps.archive_name.outputs.version-part }}
        PRODUCT_NAME: "Ainara Polaris" # From your package.json
      run: |
        echo "Preparing artifacts. Final archive name: $ARCHIVE_FILENAME"
        ORIGINAL_ARTIFACT_PATH=""
        EB_GENERATED_UPDATE_YML_NAME="" # This will be latest.yml or latest-mac.yml

        # Common search directories for electron-builder output
        # Adjust these if your electron-builder output structure is different based on ls -R dist
        SEARCH_DIRS=( "dist" "dist/win-unpacked" "dist/mac" "dist/mac-${ARCH_SUFFIX}" "dist/linux-unpacked" )

        if [ "${{ runner.os }}" == "Windows" ]; then
          EB_GENERATED_UPDATE_YML_NAME="latest.yml"
          for dir in "${SEARCH_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              # Find the Setup EXE. electron-builder might name it "PRODUCT_NAME Setup VERSION.exe"
              # Or just PRODUCT_NAME-VERSION.exe if nsis-web target
              FOUND_EXE=$(find "$dir" -maxdepth 1 \( -name "$PRODUCT_NAME Setup*.exe" -o -name "$PRODUCT_NAME-*.exe" \) -print -quit)
              if [ -n "$FOUND_EXE" ]; then ORIGINAL_ARTIFACT_PATH="$FOUND_EXE"; break; fi
            fi
          done
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          EB_GENERATED_UPDATE_YML_NAME="latest-mac.yml"
          for dir in "${SEARCH_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              # DMG name can be "PRODUCT_NAME-VERSION-ARCH.dmg" or "PRODUCT_NAME-VERSION.dmg"
              # Prefer arch-specific name if it exists, then generic.
              FOUND_DMG=$(find "$dir" -maxdepth 1 \( -name "$PRODUCT_NAME-*$ARCH_SUFFIX.dmg" -o -name "$PRODUCT_NAME-*.dmg" \) -print -quit)
              if [ -n "$FOUND_DMG" ]; then ORIGINAL_ARTIFACT_PATH="$FOUND_DMG"; break; fi
            fi
          done
        fi

        if [ -z "$ORIGINAL_ARTIFACT_PATH" ] || [ ! -f "$ORIGINAL_ARTIFACT_PATH" ]; then
          echo "::error::Original artifact not found! Searched in ${SEARCH_DIRS[*]}. Listing dist:"
          ls -R dist
          exit 1
        fi
        echo "Found original artifact: $ORIGINAL_ARTIFACT_PATH"
        mv "$ORIGINAL_ARTIFACT_PATH" "$ARCHIVE_FILENAME"
        echo "Renamed to: $ARCHIVE_FILENAME"
        echo "final_artifact_path=$ARCHIVE_FILENAME" >> $GITHUB_OUTPUT

        # Locate and process electron-builder's main update YAML (latest.yml or latest-mac.yml)
        ORIGINAL_EB_UPDATE_YML_PATH=""
        for dir in "${SEARCH_DIRS[@]}"; do # Search in dist and its subdirectories where electron-builder might place it
          if [ -d "$dir" ] && [ -f "$dir/$EB_GENERATED_UPDATE_YML_NAME" ]; then
            ORIGINAL_EB_UPDATE_YML_PATH="$dir/$EB_GENERATED_UPDATE_YML_NAME"
            break
          fi
        done

        if [ -f "$ORIGINAL_EB_UPDATE_YML_PATH" ]; then
          echo "Found electron-builder update YAML: $ORIGINAL_EB_UPDATE_YML_PATH"
          # Update 'path:' and the first 'url:' under 'files:' to the new ARCHIVE_FILENAME
          # Using yq would be safer: yq e '(.path = strenv(ARCHIVE_FILENAME)) | (.files[0].url = strenv(ARCHIVE_FILENAME))' -i "$ORIGINAL_EB_UPDATE_YML_PATH"
          sed -i.bak -e "s|^path: .*|path: $ARCHIVE_FILENAME|" \
                     -e "/^files:/,/^  - url:/{s|^  - url: .*|  - url: $ARCHIVE_FILENAME|;}" "$ORIGINAL_EB_UPDATE_YML_PATH"


          FINAL_UPDATE_YML_PATH_NAME_FOR_UPLOAD="$([ "${{ runner.os }}" == "macOS" ] && echo "latest-mac-${ARCH_SUFFIX}.yml" || echo "$EB_GENERATED_UPDATE_YML_NAME")"
          mv "$ORIGINAL_EB_UPDATE_YML_PATH" "$FINAL_UPDATE_YML_PATH_NAME_FOR_UPLOAD"
          echo "Processed and moved electron-builder YAML to $FINAL_UPDATE_YML_PATH_NAME_FOR_UPLOAD"
          echo "final_update_yml_path=$FINAL_UPDATE_YML_PATH_NAME_FOR_UPLOAD" >> $GITHUB_OUTPUT
        else
          echo "::warning::Electron-builder generated $EB_GENERATED_UPDATE_YML_NAME not found in ${SEARCH_DIRS[*]} or dist/. Auto-update might be affected."
        fi

    - name: Debug VERSION_PART
      shell: bash
      run: |
        echo "VERSION_PART is: ${{ steps.archive_name.outputs.version-part }}"
        echo "All env vars:"
        env | grep VERSION || true

    - name: Package testing artifacts
      uses: actions/upload-artifact@v4
      with:
        # Use a unique name for each artifact bundle from the matrix job
        name: build-output-${{ runner.os }}-${{ matrix.arch_suffix || 'default' }}
        path: |
          ${{ steps.prep_artifacts.outputs.final_artifact_path }}
          ${{ steps.prep_artifacts.outputs.final_update_yml_path }}
        if-no-files-found: error

  # New job to consolidate and publish the release
  publish_release:
    name: Assemble and Publish Release
    runs-on: ubuntu-latest
    needs: build # Depends on the matrix build job
    if: startsWith(github.ref, 'refs/tags/') # Only run for tag pushes
    permissions:
      contents: write # Required to create/update releases
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
    - name: Checkout code # Optional, if you need scripts from your repo
      uses: actions/checkout@v3

    - name: Install yq (YAML processor for safer YAML manipulation)
      run: |
        sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq && sudo chmod +x /usr/bin/yq
        yq --version

    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      # No 'name' specified, so it downloads all artifacts produced by 'needs' jobs
      # Each artifact bundle will be in a subdirectory named after its upload name
      # e.g., ./build-output-windows-latest-default/, ./build-output-macos-13-x64/, etc.

    - name: Debug downloaded files
      run: ls -R .

    - name: Prepare Release Assets and Consolidate Auto-Update YAMLs
      id: assemble_assets
      shell: bash
      run: |
        RELEASE_VERSION_FULL=$(echo "${{ github.ref_name }}" | sed 's/testing-v//;s/release-v//;s/v//') # Extracts "0.5.2"
        RELEASE_DATE=$(date -u +'%Y-%m-%dT%H:%M:%S.%3NZ')
        UPLOAD_FILES_LIST="" # Accumulator for all asset file paths for the release

        # --- Windows ---
        WINDOWS_DIR=$(find . -type d -name "build-output-windows-latest*" -print -quit)
        if [ -d "$WINDOWS_DIR" ]; then
          WINDOWS_EXE=$(find "$WINDOWS_DIR" -name "*.exe" -print -quit)
          EB_LATEST_YML=$(find "$WINDOWS_DIR" -name "latest.yml" -print -quit) # This is the one processed in build job

          if [ -f "$WINDOWS_EXE" ]; then UPLOAD_FILES_LIST+="$WINDOWS_EXE "; fi
          if [ -f "$EB_LATEST_YML" ]; then UPLOAD_FILES_LIST+="$EB_LATEST_YML "; fi
        else
          echo "::warning::Windows build artifacts not found in $WINDOWS_DIR"
        fi

        # --- macOS ---
        CONSOLIDATED_LATEST_MAC_YML_NAME="latest-mac.yml"
        echo "version: $RELEASE_VERSION_FULL" > $CONSOLIDATED_LATEST_MAC_YML_NAME
        echo "releaseDate: $RELEASE_DATE" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
        echo "files:" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
        MAC_PRIMARY_PATH_SET=false
        MAC_FILES_COUNT=0

        # Process ARM64 Mac
        MAC_ARM64_DIR=$(find . -type d -name "build-output-macos-*-arm64*" -print -quit)
        if [ -d "$MAC_ARM64_DIR" ]; then
          MAC_ARM64_DMG=$(find "$MAC_ARM64_DIR" -name "*.dmg" -print -quit)
          # This is the arch-specific latest-mac-arm64.yml generated by electron-builder and renamed in build job
          EB_LATEST_MAC_ARCH_YML=$(find "$MAC_ARM64_DIR" -name "latest-mac-arm64.yml" -print -quit)

          if [ -f "$MAC_ARM64_DMG" ]; then UPLOAD_FILES_LIST+="$MAC_ARM64_DMG "; fi
          if [ -f "$EB_LATEST_MAC_ARCH_YML" ] && [ -f "$MAC_ARM64_DMG" ]; then
            URL_ARM64=$(yq e '.files[0].url' "$EB_LATEST_MAC_ARCH_YML") # Assumes first file entry is the correct one
            SHA512_ARM64=$(yq e '.files[0].sha512' "$EB_LATEST_MAC_ARCH_YML")
            SIZE_ARM64=$(yq e '.files[0].size' "$EB_LATEST_MAC_ARCH_YML")
            echo "  - url: $URL_ARM64" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
            echo "    sha512: $SHA512_ARM64" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
            echo "    size: $SIZE_ARM64" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
            MAC_FILES_COUNT=$((MAC_FILES_COUNT + 1))
            if [ "$MAC_PRIMARY_PATH_SET" = false ]; then
              yq e ".path = \"$URL_ARM64\" | .sha512 = \"$SHA512_ARM64\"" -i $CONSOLIDATED_LATEST_MAC_YML_NAME
              MAC_PRIMARY_PATH_SET=true
            fi
          else
            echo "::warning::DMG or arch-specific YAML not found for ARM64 Mac in $MAC_ARM64_DIR"
          fi
        else
          echo "::warning::ARM64 Mac build artifacts directory not found."
        fi

        # Process X64 Mac
        MAC_X64_DIR=$(find . -type d -name "build-output-macos-*-x64*" -print -quit)
        if [ -d "$MAC_X64_DIR" ]; then
          MAC_X64_DMG=$(find "$MAC_X64_DIR" -name "*.dmg" -print -quit)
          EB_LATEST_MAC_ARCH_YML=$(find "$MAC_X64_DIR" -name "latest-mac-x64.yml" -print -quit)

          if [ -f "$MAC_X64_DMG" ]; then UPLOAD_FILES_LIST+="$MAC_X64_DMG "; fi
          if [ -f "$EB_LATEST_MAC_ARCH_YML" ] && [ -f "$MAC_X64_DMG" ]; then
            URL_X64=$(yq e '.files[0].url' "$EB_LATEST_MAC_ARCH_YML")
            SHA512_X64=$(yq e '.files[0].sha512' "$EB_LATEST_MAC_ARCH_YML")
            SIZE_X64=$(yq e '.files[0].size' "$EB_LATEST_MAC_ARCH_YML")
            echo "  - url: $URL_X64" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
            echo "    sha512: $SHA512_X64" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
            echo "    size: $SIZE_X64" >> $CONSOLIDATED_LATEST_MAC_YML_NAME
            MAC_FILES_COUNT=$((MAC_FILES_COUNT + 1))
            if [ "$MAC_PRIMARY_PATH_SET" = false ]; then
              yq e ".path = \"$URL_X64\" | .sha512 = \"$SHA512_X64\"" -i $CONSOLIDATED_LATEST_MAC_YML_NAME
              MAC_PRIMARY_PATH_SET=true
            fi
          else
            echo "::warning::DMG or arch-specific YAML not found for X64 Mac in $MAC_X64_DIR"
          fi
        else
          echo "::warning::X64 Mac build artifacts directory not found."
        fi

        if [ "$MAC_FILES_COUNT" -gt 0 ]; then
          UPLOAD_FILES_LIST+="$CONSOLIDATED_LATEST_MAC_YML_NAME "
        else
          echo "::warning::No Mac files found to include in $CONSOLIDATED_LATEST_MAC_YML_NAME. It will not be uploaded."
          rm -f $CONSOLIDATED_LATEST_MAC_YML_NAME # Remove empty or incomplete yml
        fi

        echo "Final list of asset files to upload: $UPLOAD_FILES_LIST"
        # Convert space-separated string to newline-separated for GITHUB_OUTPUT, filter empty lines
        echo "asset_paths=$(echo "$UPLOAD_FILES_LIST" | tr ' ' '\n' | sed '/^$/d')" >> $GITHUB_OUTPUT

    - name: Create testing release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        name: Testing Release ${{ github.ref_name }} # More descriptive name
        body: |
          Automated testing release.
          Version: $(echo "${{ github.ref_name }}" | sed 's/.*-v//')
          SHA: ${{ github.sha }}
          Contains Windows (x64), macOS (x64, arm64) builds.
        draft: false
        prerelease: true
        fail_on_unmatched_files: true # Important: fail if any listed files are not found
        files: ${{ steps.assemble_assets.outputs.asset_paths }}
